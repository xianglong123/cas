## 回收策略算法
    在jvm虚拟机中，程序计数器，java虚拟机栈和本地方法栈的生命周期伴随线程的创建到消亡，这部分对内存的占用是可确定的。
    但是对于一个应用需要多少个对象，这个对于虚拟机而言是不确定的，所以我们得动态的回收他们，这就有了一个疑问"哪些对象是需要被回收的？"
    所以我们引入了判断对象可回收的算法；
    
### 引用计数法
    也就是如果一个对象被引用，那么我们就在某个计数上+1，反之如果没被引用我们就-1，这样判断对象如果计数是0就是可以清除的对象，但是这里存在一个
    弊端，就是如果A和B对象相互引用就会导致两个应该被判定为需要清除的对象无法被清除，所以后面有一哥们儿又提出了可达性算法
### 可达性算法
    就是我们找若干个Gc roots从这里向下找引用，如果对象被引用就标记为存活的对象，如果没被引用就判断是需要被清除的对象。现在大部分收集器判断对象
    是否死亡都是用的可达性算法
    GC ROOTS的对象包括：
    1.在虚拟机栈中引用的对象
    2.在方法区中类静态属性引用的对象
    3.在方法区中常量引用的对象
    4.在本地方法栈中JNI引用的对象
    5.Java虚拟机内部的引用
    6.所有同步锁持有的对象
    7.反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等

## 垃圾收集算法
### 垃圾分代理论
    分代假说：
    弱分代假说：大部分对象都是朝生夕灭的
    强分代假说：熬过越多次垃圾收集的对象就越难消亡
    所以大神们就根据这两个分代假说将虚拟机分为新生代和老年代两个部分
    注意：假设有少数老年代对象引用了新生代对象，按道理我们是不应该清除新生代的对象的，因此我们可能会花费大量资源以老年代对象为GC ROOTS向下寻找对象
    但是我们要知道和老年代对象有关的对象也会慢慢的晋升为新生代对象，所以有一哥们儿又提出一个假说：
    跨代引用假说：跨代引用相对于同代引用仅仅占极少数
    所以我们不应为了极少数情况浪费大量资源
    
### 标记-清除算法
    过程：将需要清除的标记，然后统一清除标记对象
    优点：需要清除对象少的时候，标记和清除两步效率高
    缺点：1.产生大量碎片化内存  2.执行效率不稳定，如果又大量对象需要清除，效率低
    
### 标记-复制
    过程：将内存分为两半，对象只分配其中一块，垃圾回收后将存活对象复制到另一块内存，再清除当前内存
    优点：可以有规整的内存
    缺点：1.内存使用率低，每次都有一般内存不能使用  
    备注：这个后来应用于CMS收集器的幸存区的应用

### 标记-整理
    过程：清除后对存活对象进行移动
    优点：有规整内存，可供对象分配
    缺点：移动需要"stop the world"占用用户线程，体验不好
    备注：后来有一个哥们就说咱们呢就别整这玄玄呼呼的东西，咱们就先标记-清除，有空间咱们就分配，楞要是有大对象，咱们就标记-整理
    
 


